<!-- broadcaster.html -->
<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Broadcaster</title>
</head>

<body
  style="font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
  <label>あなたのID: <input id="myId" value="broadcaster1"></label>
  <label>サーバーIP: <input id="serverHost" value="localhost"></label>
  <button id="startBtn">カメラ開始 & サーバ接続</button>
  <button id="stopBtn" disabled>配信停止</button>
  <button id="switchCameraBtn" disabled>カメラ切替</button>
  <div id="status">未開始</div>
  <div id="cameraInfo" style="margin: 5px 0; font-size: 14px; color: #666;">カメラ: 未選択</div>
  <div id="debug" style="background:#f0f0f0; padding:10px; margin:10px 0; font-size:12px;"></div>
  <video id="localVideo" autoplay playsinline muted style="width:320px;height:240px;background:#000"></video>

  <script>
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    let pcMap = new Map(); // viewerId -> RTCPeerConnection
    let localStream = null;
    let ws = null;
    let myId = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 3;
    let currentCameraIndex = 0;
    let availableCameras = [];

    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
      console.log('Status:', msg);
    }

    function addDebugLog(msg) {
      const debugDiv = document.getElementById('debug');
      const time = new Date().toLocaleTimeString();
      debugDiv.innerHTML += `<div>${time}: ${msg}</div>`;
      debugDiv.scrollTop = debugDiv.scrollHeight;
      console.log('Debug:', msg);
    }

    function updateButtons(isStreaming) {
      document.getElementById('startBtn').disabled = isStreaming;
      document.getElementById('stopBtn').disabled = !isStreaming;
      document.getElementById('switchCameraBtn').disabled = !isStreaming || availableCameras.length <= 1;
    }

    function updateCameraInfo() {
      const infoDiv = document.getElementById('cameraInfo');
      if (availableCameras.length > 0) {
        const currentCamera = availableCameras[currentCameraIndex];
        const facingMode = currentCamera.facingMode || '不明';
        infoDiv.textContent = `カメラ: ${currentCamera.label || 'カメラ ' + (currentCameraIndex + 1)} (${facingMode})`;
      } else {
        infoDiv.textContent = 'カメラ: 未選択';
      }
    }

    async function getAvailableCameras() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices
          .filter(device => device.kind === 'videoinput')
          .map((device, index) => ({
            deviceId: device.deviceId,
            label: device.label || `カメラ ${index + 1}`,
            facingMode: device.label.toLowerCase().includes('front') || device.label.toLowerCase().includes('user') ? 'フロント' :
              device.label.toLowerCase().includes('back') || device.label.toLowerCase().includes('environment') ? 'リア' : '不明'
          }));

        addDebugLog(`利用可能なカメラ: ${availableCameras.length}台`);
        availableCameras.forEach((camera, index) => {
          addDebugLog(`  ${index + 1}: ${camera.label} (${camera.facingMode})`);
        });

        return availableCameras;
      } catch (error) {
        console.error('カメラ列挙エラー:', error);
        return [];
      }
    }

    async function getCameraStream(cameraIndex = 0) {
      const constraints = {
        video: {
          deviceId: availableCameras[cameraIndex] ? { exact: availableCameras[cameraIndex].deviceId } : undefined,
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30, max: 30 }
        },
        audio: true
      };

      if (availableCameras.length === 0) {
        // フォールバック: facingModeを使用
        constraints.video = {
          facingMode: cameraIndex === 0 ? 'user' : 'environment',
          width: { ideal: 640 },
          height: { ideal: 480 },
          frameRate: { ideal: 30, max: 30 }
        };
      }

      return await navigator.mediaDevices.getUserMedia(constraints);
    }

    async function switchCamera() {
      if (availableCameras.length <= 1) {
        addDebugLog('切り替え可能なカメラがありません');
        return;
      }

      try {
        updateStatus('カメラを切り替え中...');
        addDebugLog('カメラ切り替え開始');

        // 次のカメラインデックス
        currentCameraIndex = (currentCameraIndex + 1) % availableCameras.length;

        // 現在のストリームを停止
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
        }

        // 新しいカメラストリームを取得
        localStream = await getCameraStream(currentCameraIndex);
        document.getElementById('localVideo').srcObject = localStream;
        updateCameraInfo();

        // 既存の接続にトラックを更新
        for (const [viewerId, pc] of pcMap) {
          const videoSender = pc.getSenders().find(sender =>
            sender.track && sender.track.kind === 'video'
          );

          if (videoSender) {
            const newVideoTrack = localStream.getVideoTracks()[0];
            await videoSender.replaceTrack(newVideoTrack);
            addDebugLog(`視聴者 ${viewerId} のビデオトラックを更新`);
          }
        }

        updateStatus('カメラ切り替え完了');
        addDebugLog(`カメラを ${availableCameras[currentCameraIndex].label} に切り替えました`);

      } catch (error) {
        console.error('カメラ切り替えエラー:', error);
        addDebugLog(`カメラ切り替えエラー: ${error.message}`);
        updateStatus('カメラ切り替えエラー');

        // エラー時は元のカメラに戻す
        currentCameraIndex = (currentCameraIndex - 1 + availableCameras.length) % availableCameras.length;
      }
    }

    function connectWebSocket() {
      const serverHost = document.getElementById('serverHost').value || 'localhost';
      const wsUrl = `wss://${serverHost}:3000`;

      addDebugLog(`WebSocket接続試行... (${wsUrl})`);
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        updateStatus('WebSocket接続完了。登録中...');
        addDebugLog('WebSocket接続が開かれました');
        reconnectAttempts = 0;

        setTimeout(() => {
          const registerMsg = JSON.stringify({ type: 'register', id: myId, role: 'broadcaster' });
          addDebugLog(`登録メッセージ送信: ${registerMsg}`);
          ws.send(registerMsg);
          updateStatus('サーバー登録完了。配信準備完了');
        }, 100);
      };

      ws.onmessage = async (ev) => {
        const msg = JSON.parse(ev.data);
        addDebugLog(`受信メッセージ: ${JSON.stringify(msg)}`);

        if (msg.kind === 'viewer-join') { // viewer asks to start
          const viewerId = msg.from;
          updateStatus(`視聴者 ${viewerId} が参加。接続中...`);
          await createOfferForViewer(viewerId);
        } else if (msg.payload && msg.kind === 'answer') {
          const viewerId = msg.from;
          addDebugLog(`${viewerId} からAnswerを受信`);
          const pc = pcMap.get(viewerId);
          if (!pc) return;
          await pc.setRemoteDescription(new RTCSessionDescription(msg.payload));
          updateStatus(`視聴者 ${viewerId} と接続完了`);
        } else if (msg.payload && msg.kind === 'candidate') {
          const pc = pcMap.get(msg.from);
          if (pc) {
            addDebugLog(`ICE候補を受信: ${msg.from}`);
            pc.addIceCandidate(new RTCIceCandidate(msg.payload));
          }
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocketエラー:', error);
        addDebugLog(`WebSocketエラー: ${error.type || 'unknown'}`);
        updateStatus('WebSocket接続エラー');
      };

      ws.onclose = (event) => {
        console.log('WebSocket接続が閉じられました:', event.code, event.reason);
        addDebugLog(`WebSocket接続が閉じられました - コード: ${event.code}, 理由: ${event.reason || 'なし'}`);
        updateStatus('WebSocket接続が閉じられました');
        updateButtons(false);
      };
    }

    function stopStreaming() {
      addDebugLog('配信停止処理を開始');

      // すべてのPeerConnection接続を閉じる
      for (const [viewerId, pc] of pcMap) {
        addDebugLog(`視聴者 ${viewerId} との接続を閉じます`);
        pc.close();
      }
      pcMap.clear();

      // 視聴者に配信停止を通知
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          broadcast: 'viewer',
          kind: 'stream-ended',
          payload: null
        }));
        addDebugLog('視聴者に配信停止を通知');
      }

      // ローカルストリームを停止
      if (localStream) {
        localStream.getTracks().forEach(track => {
          addDebugLog(`トラックを停止: ${track.kind}`);
          track.stop();
        });
        localStream = null;
      }

      // ビデオ要素をクリア
      document.getElementById('localVideo').srcObject = null;

      // WebSocket接続を閉じる
      if (ws) {
        ws.close();
        ws = null;
      }

      // カメラ情報をリセット
      availableCameras = [];
      currentCameraIndex = 0;
      updateCameraInfo();

      updateStatus('配信停止完了');
      updateButtons(false);
      addDebugLog('配信停止処理完了');
    }

    document.getElementById('startBtn').onclick = async () => {
      try {
        myId = document.getElementById('myId').value || 'broadcaster1';
        addDebugLog(`開始 - ID: ${myId}`);

        updateStatus('カメラデバイスを検索中...');

        // 利用可能なカメラを取得
        await getAvailableCameras();

        updateStatus('カメラにアクセス中...');

        localStream = await getCameraStream(currentCameraIndex);
        document.getElementById('localVideo').srcObject = localStream;
        updateCameraInfo();

        addDebugLog(`カメラアクセス成功 - ビデオ: ${localStream.getVideoTracks().length}トラック, オーディオ: ${localStream.getAudioTracks().length}トラック`);
        updateStatus('カメラ開始完了。サーバーに接続中...');
        updateButtons(true);

        connectWebSocket();

      } catch (error) {
        console.error('エラー:', error);
        addDebugLog(`初期化エラー: ${error.message}`);
        updateStatus('エラー: ' + error.message);
        updateButtons(false);
      }
    };

    document.getElementById('stopBtn').onclick = () => {
      stopStreaming();
    };

    document.getElementById('switchCameraBtn').onclick = () => {
      switchCamera();
    };

    async function createOfferForViewer(viewerId) {
      addDebugLog(`視聴者 ${viewerId} 用のOfferを作成中`);
      const pc = new RTCPeerConnection(configuration);

      // send local tracks
      for (const t of localStream.getTracks()) {
        addDebugLog(`トラックを追加: ${t.kind} - ${t.label}`);
        pc.addTrack(t, localStream);
      }

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          addDebugLog(`ICE候補を送信: ${viewerId}`);
          ws.send(JSON.stringify({ target: viewerId, kind: 'candidate', payload: e.candidate }));
        }
      };

      pc.onconnectionstatechange = () => {
        addDebugLog(`${viewerId} 接続状態: ${pc.connectionState}`);
      };

      pcMap.set(viewerId, pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      addDebugLog(`${viewerId} にOfferを送信`);
      ws.send(JSON.stringify({ target: viewerId, kind: 'offer', payload: pc.localDescription }));
    }
  </script>
</body>

</html>